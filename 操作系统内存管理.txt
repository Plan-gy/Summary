外存-主存-缓存-寄存器
指令和数据绑定在内存地址可以在三个不同的阶段发生
编译时期：如果内存位置已知，可生成代码，如果开始位置改变，需要重新编译代码
装入时期：如果存储地位置在编译时不知道，则必定生成可重定位代码
执行时期：如果进程在执行时可以在内存中移动，则地址绑定要延迟到运行时。需要硬件对地址映射的支持

在编译时期和装入时期的地址绑定策略生成的逻辑地址和物理地址是相同的，执行时地址绑定策略是不同的
地址重定位：将程序装入到与其地址空间不一致的物理空间，所引起的一系列地址转换
静态重定位：就是在装入时期就变换好
动态重定位：就是在装入时期不变，运行时期通过计算等算出地址(基质+变址)

连续分配方式：为一个程序分配一段连续的内存空间。
固定分区是在作业装入之前，内存被划分为若干个固定大小的连续分区。
在系统运行期间不在重新划分，即分区个数不变，分区大小不变，又称为静态分区。
系统有张分区说明表，说明每个分区的大小，起始地址，是否已分配的使用标志

分区的划分是动态的，不是预先确定的。如果空间不够，哪这个就必须要等待

最佳适应算法：从空间区中找到满足作业要求的，且最小的分区
			使得碎片尽量小
			空闲分区要从小到大排列
解决碎片的方法是拼接：向一个方向移动已分配的作业，是的零散的小空闲区在一个方向连城一片
动态重定位才能紧缩，拼接

IO问题：要么就把工作锁定在内存中，或者只对OS的缓冲区进行IO

进程的物理地址可以是不连续的，如果有可用地址就分配给进程
把物理内存分成大小固定的块
把逻辑内存也分为大小固定的块，叫做页
保留所有空闲帧的记录
运行一个N页大小的程序，就要找N个空的页框读入程序
建立一个页表，用来把逻辑地址转换为物理地址
产生内碎片
逻辑地址到物理地址的映射。
CPU产生的地址分为：
	页号：页在物理内存中的基址，用来作为页表的索引
	偏移：同基址相结合，用来确定送入内存设备的物理内存地址
先用页号在页表中找到地址，在用偏移和地址找到位置

特点：没有外碎片，但是有内碎片，内碎片不会超过页大小。程序不必连续存放。程序全部装入内存。

页表比较小可以放在寄存器中，如果比较大就放在主存中。
页表基址寄存器(PTBR)指向页表
页表限长寄存器(PRLR)表明页表的长度
每次数据指令存取需要两次内存存取：一次存取页表，一次存取数据

联想寄存器(TLB)--并行查找page---frame(p,d)最近访问的页内容存放在这
如果p在联想寄存器，就把页框取出来。否则从内存中的页表取出页框
有效存取时间=(内存一次存取时间a+联想寄存器查找时间b)*命中率+(2a+b)*未命中率
页表始址和页表长度存放在进程的PCB中。
1、有效的地址寄存器中存放的页号和偏移量
2、在页表寄存器中查看页表始址和页表长度，如果页号超过页表的长度说明不正确，越界中断
3、根据页号在页表中查找快号
4、5、将块号(高址)和偏移量(低址)放在物理地址寄存器中得到物理地址，在内存中找到

页表比较小可以放在寄存器中，如果比较大就放在主存中。
页表基址寄存器(PTBR)指向页表
页表限长寄存器(PRLR)表明页表的长度
每次数据指令存取需要两次内存存取：一次存取页表，一次存取数据

联想寄存器(TLB)--并行查找page---frame(p,d)最近访问的页内容存放在这
如果p在联想寄存器，就把页框取出来。否则从内存中的页表取出页框
有效存取时间=(内存一次存取时间a+联想寄存器查找时间b)*命中率+(2a+b)*未命中率
页表始址和页表长度存放在进程的PCB中。
1、有效的地址寄存器中存放的页号和偏移量
2、在页表寄存器中查看页表始址和页表长度，如果页号超过页表的长度说明不正确，越界中断
3、根据页号在页表中查找快号
4、5、将块号(高址)和偏移量(低址)放在物理地址寄存器中得到物理地址，在内存中找到

逻辑地址：包括两部分--段号，段偏移
段表存储基址和限长
先用段号查段表，找到起始地址，和段的长度，用段长和段偏移做比较，如果段偏移比段长长不合法就陷入非法内存访问异常，将起始地址和段偏移想加就得到了物理地址
段表基址寄存器指向段表在内存中的地址
段表限长寄存器表明被一个程序所使用的段的数目
