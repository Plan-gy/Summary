常规存储器的特征：
一次性：作业在运行前一次性全部装入内存
驻留性：作业装入内存后，便一直驻留在内存中，直到作业结束
正是由于一次性和驻留性，是的程序中暂时不用的数据占用了大量的内存空间，从而需要
运行的作业无法装入内存。

程序局部性原理：在一段时间内，程序的执行仅仅局限于某个部分；相应的它所访问的存储
空间也局限于某个区域。
时间局部性：程序的某条指令/存储单元一旦执行，则不久将来该指令/存储单元还会被执行
因为程序中存在着大量的循环结构
空间局部性：一旦程序访问了某个存储单元，则不久将来，其附近的存储单元也可能被访问
因为程序大多都是顺序执行的。

虚拟内存：是一种允许进程部分装入内存就可以执行的技术。
	• 局部性原理
	• 只有运行的部分程序需要在内存中
	• 逻辑地址空间能够比物理空间大
	• 必须允许页面能够被换入和换出


虚拟存储的特征：
	• 离散性：在内存中采用离散的分配方式，是虚拟存储器的最基本特征。
	• 多次性：一个作业被分为多次调入到内存，没必要全部装入内存，只要将当前要运行的部分程序和数据装入内存即可，是虚拟存储器的最重要特征。
	• 对换性：作业运行过程中信息在内存和外存的对换区之间换入，换出
	• 虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远大于实际内存容量

实现虚拟存储器要解决：
	1. 程序部分运行可以吗？
	取页---将所需的部分装入内存
	2. 发现程序不在内存中，如何将其装入后继续运行？
	请求调页---缺页时，产生缺页中断，将外存上的页调入内存中
	3. 内存无空间咋办？
	页面置换----内存不足时，将一些页换出内存
	
	
	
为能使程序运行，事先需将一部分要执行的程序和数据调入内存
预调页策略：主动的页面调入策略，把那些预计很快会被访问的程序或数据所在的页面预先调入内存
			预测的准确性不高，主要用于进程的首次调入。
请求调页策略：当程序运行中发生缺页，由系统将缺页调入内存。调页时花费较大的开销。



缺页中断和一般中断的区别;
	• 缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完后检查和处理中断信号
	• 缺页中断返回到该指令的开始重新执行该指令，而一般中断返回到该指令的下一条指令执行
	• 一条指令执行期间，可能产生多次缺页中断
缺页中断：
	1. 查找页表来确定此次地址访问是否合法
	2. 如果不合法，则终止进程，否则如果有效但不在内存中，说明发生缺页，就要将其调入内存
	3. 所需的页在外存，找到该页
	4. 找一个空闲物理页，启动磁盘，把该页读入内存中。
	5. 读磁盘结束，修改页表指出该页已在内存中。
	6. 重新开始执行刚才发生缺页的中断指令，这时候可以访问刚才调入的页。



页面置换

请求调页

在进程运行过程中，如果发生缺页，而且内存中又没有空闲块，就要发生页面置换。
将内存中某一页换到磁盘的对换区。
最优算法：被置换的页将是之后最长时间不被使用的页
是一个理论的最优算法，因为不知道后面的序列，可以用来衡量算法的效率

先进先出置换算法(FIFO)：将最先进入队列的页进行置换。

LRU：选择最近最少使用的页进行置换。(最长时间没有使用的页)
实现LRU算法需要硬件支持，记录物理帧的使用情况

LRU近似算法：
	• 访问位：每个页都与一个位相关联,初始值为.当页是访问页时置为1.如果存在的话,置换位为0的页
	• 二次机会：也需要访问位，以顺时针的顺序查看，如果当前这个页的访问位是1，就将其置为0，将页留在内存中，找下一个页。如果所有的页都访问位是1，则此算法退化为FIFO算法
平均分配：每个进程平均分配

按比例分配：根据进程大小来分。(此进程所需大小)/总需大小*实际总共大小

按照优先级而不是大小使用比例分配策略：

如果进程产生缺页
全局替换：进程在所有的页中选择一个替换页面，一个进程可以从另一个进程中获得页面
局部替换：每个进程只能在属于它自己的页中选择。

固定分配&局部置换策略
为每个进程分配固定数目的物理块，在整个运行期间不变，如果发生缺页，只能从该进程已在内存的页面选择一页，调入另一页，保证分配给该进程的内存空间不变
可变分配&全局置换策略
系统为进程分配一定数目的物理块，OS本身也保持一个空闲物理队列，当发生缺页，系统从空闲物理队列中，取出一物理块分配给该进程，并将欲调入的缺页装入其中。当空闲队列用完后，才从内存中选取一页来替换。
可变分配&局部策略
系统为进程分配一定数目的物理块，并且在运行期间可根据情况来适当的增减锁分配的物理块数
如果发生缺页，只能从该进程已在内存的页面选择一页，调入另一页，不影响其他线程运行

一个进程的页面经常换入换出，花费在页面换入换出的时间大于进程的执行时间就叫做颠簸。
为了防止颠簸，应该给进程提供足够多的帧。
